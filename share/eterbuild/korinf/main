#!/bin/bash
# 2005, 2006, 2007, 2008 (c) Etersoft http://etersoft.ru
# Author: Vitaly Lipatov <lav@etersoft.ru>
# GNU Public License version 3
#
# Собирает пакеты для перечисленных в rebuild.list систем и копирует сборки на место.
# Пакеты собираются из опубликованных подписанных исходников
# use with builder user
# Req: etersoft-build-utils >= 1.6, alien >= 8.63

# make link to etersoft-build-utils repository to get run from the source tree
# load common functions, compatible with local and installed script
. `dirname $0`/../share/eterbuild/korinf/common

# Try to set clear environment
LC_ALL=C
unset DISPLAY

kormod mount copying install log
kormod_build main

exit_handler()
{
    local rc=$?
    trap - EXIT
    warning "Interrupted, exiting..."
    end_umount
    exit $rc
}

trap exit_handler EXIT HUP INT QUIT PIPE TERM

# Returns the newest package from the pkg list
last_rpm()
{
	local i
	local lastrpm
	local pkgver
	lastrpm="___________"
	for i in `cat` ; do
		pkgver=`rpm -qp $i`
		#echo "Compare $pkgver $lastrpm "
		LR=`rpmvercmp $pkgver $lastrpm `
		#echo "RES=$LR"
		#LR=$?
		if [ $LR -gt 0 ] ; then
			lastrpm=$pkgver
		fi
	done
	echo $lastrpm
}


main_build_phase()
{
	# On systems with portage change wine package name
	# TODO: remove BUILDNAME or PACKAGE
	[ "$BUILDNAME" = "wine" ] && PACKAGE="wine-etersoft-public" || PACKAGE=$BUILDNAME

	# TODO: remove
	[ -n "$PRODUCT" ] && EPACKAGE=$PACKAGE-$PRODUCT || EPACKAGE=$PACKAGE

	# Do use direct package name?
	if echo $BUILDNAME | grep -q "\.src\.rpm" ; then
		BUILDSRPM="$SOURCEPATH/$BUILDNAME"
	else
		BUILDSRPM="$SOURCEPATH/$(ls -1 $SOURCEPATH/$BUILDNAME-[0-9]*.src.rpm | last_rpm).src.rpm"
	fi

	if [ ! -r "$BUILDSRPM" ] ; then
		warning "Package $BUILDSRPM is not readable"
		return 1
	fi

	logit "`basename $BUILDSRPM .src.rpm`"
	
	# FIXME: move it to log_it?
	#if [ -z "$NIGHTBUILD" ] ; then
	#	rpm --checksig $BUILDSRPM || warning "GPG check failed"
	#fi

	if [ -n "$MAKESPKG" ] ; then
		build_src_pkg || return 1
	else
		build_in_dist || return 1
	fi
	logit "copying log" copying_log || return 1
}

main_build()
{
[ -n "$ADEBUG" ] && echo "BUILDNAME: $BUILDNAME"

CMDRE=$(get_distro_list $REBUILDLIST)
[ -z "$CMDRE" ] && fatal "build list is empty"

# HACK: Url for remote building
SOURCEURL=$(echo $SOURCEPATH | sed -e "s|/var/ftp/|ftp://server/|g")

for dist in $CMDRE ; do
	# Куда будем складывать собранные пакеты
	DESTDIR=$TARGETPATH/$dist
	# FIXME: Hack
	[ "$TARGETPRIVPATH" ] && DESTDIR=$TARGETPRIVPATH

	dist_ver=`echo $dist | sed -e "s|.*/||g"`
	dist_name=`echo $dist | sed -e "s|/.*||g"`
	[ -z "$dist_name" ] && fatal "Empty dist_name for $dist"

	# Initialize LOGDIR and LOGFILE variables
	init_dist_log "$dist"

	# Run build and check result
	if ! main_build_phase ; then
		# Размонтируем при ошибке, если не указано обратное
		if [ -z "$ADEBUG" ] ; then
			logit "umount" end_umount
		fi
		# Если сборка с автоспеком провалилась, опубликуем логи
		logit "copying log from broken build" copying_log

		# Если автосборка, останавливаемся на ошибке
		if [ -n "$NIGHTBUILD" ] ; then
			echo `date` $dist FATAL write_report
			fatal "Fatal autobuild"
		fi
	fi

	echo `date` $dist DONE | write_report

done

# disable trap before exit
trap - EXIT
}
