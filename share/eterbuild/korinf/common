#!/bin/bash
##
#  Korinf project
#
#  Common functions
#
#  Copyright (c) Etersoft <http://etersoft.ru> 2005-2009
#  Copyright (c) Vitaly Lipatov <lav@etersoft.ru> 2009
#
#  This program is free software: you can redistribute it and/or modify
#  it under the terms of the GNU Affero General Public License as published by
#  the Free Software Foundation, either version 3 of the License, or
#  (at your option) any later version.

#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU Affero General Public License for more details.

#  You should have received a copy of the GNU Affero General Public License
#  along with this program.  If not, see <http://www.gnu.org/licenses/>.
##

NEEDETERBUILD=162

load_etersoft_build_utils()
{
# Load etersoft-build-utils part
LOCETERBUILDDIR=`dirname $0`/../share/eterbuild/functions
RELETERBUILDDIR=../../etersoft-build-utils/share/eterbuild/functions

# Create link to etersoft-build-utils repo if not exists
if [ ! -L "$LOCETERBUILDDIR" ] ; then
	if [ ! -d "`dirname $0`/$RELETERBUILDDIR" ] ; then
		ETERBUILDDIR="/usr/share/eterbuild"
		if [ ! -d "$ETERBUILDDIR" ] ; then
			echo "Clone etersoft-build-utils git repository to the same directory as korinf checkouted" >&2
			exit 1
		fi
		ETERBUILDETC=$(realpath "$ETERBUILDDIR/../../etc")
		ETERBUILDBIN=$(realpath "$ETERBUILDDIR/../../bin")
		return
	else
		rm -f $LOCETERBUILDDIR
		ln -s ../$RELETERBUILDDIR $LOCETERBUILDDIR
	fi
fi

# HACK: set to real path
ETERBUILDDIR=$(realpath "`dirname $0`/$RELETERBUILDDIR/../../../share/eterbuild")
ETERBUILDETC=$(realpath "$ETERBUILDDIR/../../etc")
ETERBUILDBIN=$(realpath "$ETERBUILDDIR/../../bin")
if [ ! -d "$ETERBUILDDIR" ] ; then
	echo "Clone etersoft-build-utils git repository to the same directory as korinf checkouted" >&2
	exit 1
fi
}

load_etersoft_build_utils

# these variable will not override in eterbuild common
. $LOCETERBUILDDIR/common



KORINFETC=/etc/eterbuild
KORINFDIR=/usr/share/eterbuild

# if run from local installation
if ! dirname $0 | grep ^/usr/share >/dev/null ; then
	KORINFDIR=$(readlink -f `dirname $0`/../share/eterbuild)
	KORINFETC=$(readlink -f `dirname $0`/../etc)
	if [ -r "$KORINFETC/../AUTHORS" ] ; then
		if [ -n "$VERBOSE" ] ; then
			echo "Note: run from source tree, datadir=$KORINFDIR, sysconfdir=$KORINFETC"
		fi
		KORINFSOURCETREE=$(readlink -f "$KORINFETC/..")
	else
		KORINFETC=/etc/eterbuild
		KORINFDIR=/usr/share/eterbuild
	fi
fi


# Try to set clear environment
LC_ALL=C
unset DISPLAY

test `hostname` = builder.office.etersoft.ru || warning "It is tested only at Etersoft builder host!"

kormod()
{
	local i
	for i in $@ ; do
		. $KORINFDIR/korinf/$i
	done
}

# Returns the newest package from the pkg list (without extension .src.rpm)
last_rpm()
{
	local i
	local lastrpm
	local pkgver
	lastrpm="___________"
	for i in `cat` ; do
		pkgver=`rpm -qp $i`
		#echo "Compare $pkgver $lastrpm "
		LR=`rpmvercmp $pkgver $lastrpm `
		#echo "RES=$LR"
		#LR=$?
		if [ "$LR" -gt 0 ] ; then
			lastrpm=$pkgver
		fi
	done
	echo $lastrpm
}

# print out full path to src.rpm (get from BUILDNAME on SOURCEPATH)
get_src_package()
{
	local BUILDSRPM
	local SOURCEPATH="$1"
	local BUILDNAME="$2"
	# Do use direct package name?
	if echo $BUILDNAME | grep -q "\.src\.rpm" ; then
		BUILDSRPM="$SOURCEPATH/$BUILDNAME"
	else
		BUILDSRPM="$SOURCEPATH/$(ls -1 $SOURCEPATH/$BUILDNAME-[0-9]*.src.rpm 2>/dev/null | last_rpm).src.rpm"
	fi

	echo "$BUILDSRPM"
	test -r "$BUILDSRPM"
}

# print out full path to binary package (get from BUILDNAME on TARGETPATH)
get_bin_package()
{
	local BUILDPKG
	local TARGETPATH="$1"
	local BUILDNAME="$2"
	local CHECKMAINFILES="$3"
	local PATHPKG

	PATHPKG=$TARGETPATH
	if [ -n "$CHECKMAINFILES" ] && [ -z "$MAINFILESLIST" ] ; then
		PATHPKG=$TARGETPATH/extra
	fi

	# asterisk before name for possible rename NAME <-> libNAME
	BUILDPKG="$(ls -1 $PATHPKG/*$BUILDNAME[-_][0-9]* 2>/dev/null | head -n1)"

	echo $BUILDPKG
	test -r "$BUILDPKG"
}

# get distro list from arg/directory/file
# from DIR/distro.list if arg is dir
# from FILE if arg is file name
# from ARG if arg is list
get_distro_list()
{
	local i
	local LIST
	local DIR

	# get list from directory
	if [ -d "$1" ] ; then
		LIST="$1/distro.list"
		if [ ! -r "$LIST" ] ; then
			fatal "get_distro_list: $LIST is not found"
		fi
		DIR=$1
	# get list from file
	elif [ -r "$1" ] ; then
		LIST="$1"
		DIR=`dirname $1`
	# list in the variable
	else
		echo "$@"
		return
	fi

	cat "$LIST" | grep -v "^#" | grep -v "^\." | sed -e "s|[ 	].*||g" | grep -v "^\$"
	# get list included files
	LIST=`cat "$LIST" | grep "^\." | sed -e "s|^\. ||g"`
	for i in $LIST ; do
		test -f "$DIR/$i" || continue
		get_distro_list $DIR/$i
	done
}

# get distro list from TARGETPATH or lists/all
get_target_list()
{
	local TLIST
	local ALL=$1
	TLIST=$TARGETPATH/distro.list
	[ -r "$TLIST" ] || TLIST=$KORINFETC/lists/all
	[ -z "$ALL" ] || TLIST=$KORINFETC/lists/all
	[ -r "$TLIST" ] || fatal "get_target_list failed to get full list of targets"
	echo $TLIST
}

check_target_dist()
{
	local DIST="$1"
	get_distro_list $(get_target_list ALL) | grep -q "$DIST" || get_distro_list $(get_target_list) | grep -q "$DIST"
}

# Set REBUILDLIST according TARGETPATH, existing REBUILDLIST and some heruistic
set_rebuildlist()
{
	local RESULT
	if [ -n "$REBUILDLIST" ] ; then
		if [ -r "$KORINFETC/lists/$REBUILDLIST" ] ; then
			REBUILDLIST=$KORINFETC/lists/$REBUILDLIST
			RESULT="Build for distros from $REBUILDLIST"
		else
			check_target_dist $REBUILDLIST || fatal "Run with unknown target '$REBUILDLIST'"
			RESULT="Build for $REBUILDLIST"
		fi
	else
		REBUILDLIST=$(get_target_list)
		# Hack?
		if [ -r "$TARGETPATH/distro.list" ] ; then
			RESULT="Build according to distro.list from $TARGETPATH"
		else
			RESULT="Build for distros from $REBUILDLIST"
		fi
	fi
	[ -n "$QUIET" ] || echo $RESULT
}

# fills dist_ver, dist_name, dist_arch by arg with target name
parse_dist_name()
{
	local dist=$1
	local v
	# dist format: [arch/]Name/Version
	dist_ver=`echo $dist | sed -e "s|.*/||g"`
	v=`echo $dist | sed -e "s|/$dist_ver\$||g"`
	dist_name=`echo $v | sed -e "s|.*/||g"`
	dist_arch=`echo $v | sed -e "s|/.*||g"`
	# FIXME: i586 by default (DEFAULTARCH is a current arch)
	test "$dist_arch" = "$v" && dist_arch=i586
	# if parse error
	test "$dist_name" = "$dist_ver" && dist_name="" && dist_ver=""
}

# return full path to sources, detected by TARGET dir
get_rpm_sources()
{
	local TARGETPATH=$1
	local SOURCEPATH
	# WINE/Distro/Version or x86_64/Distro/Version
	SOURCEPATH="$(readlink -f "$TARGETPATH/../../../sources")"
	# Distro/Version or x86_64/Distro
	[ -d "$SOURCEPATH" ] || SOURCEPATH="$(readlink -f "$TARGETPATH/../../sources")"
	# WINE/x86_64/Distro/Version
	[ -d "$SOURCEPATH" ] || SOURCEPATH="$(readlink -f "$TARGETPATH/../../../../sources")"
	# Distro (Windows)
	[ -d "$SOURCEPATH" ] || SOURCEPATH="$(readlink -f "$TARGETPATH/../sources")"
	echo "$SOURCEPATH"
}

kormod config log
